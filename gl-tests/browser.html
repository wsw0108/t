<!DOCTYPE html>
<html>

<head>
  <title>gl tests</title>
  <script src="./utils-browser.js"></script>
</head>

<body>
  <canvas id="canvas" width="512" height="512"></canvas>
  <script>
    const canvas = document.getElementById('canvas')
    const gl = canvas.getContext('webgl')
    const limits = {
      MAX_VERTEX_UNIFORM_VECTORS: 1024,
      MAX_VARYING_VECTORS: 30,
      MAX_FRAGMENT_UNIFORM_VECTORS: 1024,
      MAX_TEXTURE_SIZE: 16384,
      MAX_VIEWPORT_DIMS: [32767, 32768],
      MAX_VERTEX_ATTRIBS: 16,
      MAX_COMBINED_TEXTURE_IMAGE_UNITS: 32,
      MAX_VERTEX_TEXTURE_IMAGE_UNITS: 16,
      MAX_TEXTURE_IMAGE_UNITS: 16,
      MAX_CUBE_MAP_TEXTURE_SIZE: 16384,
      MAX_RENDERBUFFER_SIZE: 16384
    }
    Object.keys(limits).forEach(key => {
      const limit = gl.getParameter(gl[key])
      console.log(`${key}: ${limit}`)
    })

    var vertexSrc = `
  attribute vec2 a_position;

  void main() {
    gl_Position = vec4(a_position, 0, 1);
    gl_PointSize = 20.0;
  }
  `

    var fragmentSrc = `
  void main() {
    gl_FragColor = vec4(0, 1, 0, 1);  // green
  }
  `

    // setup a GLSL program
    var program = createProgramFromSources(gl, [vertexSrc, fragmentSrc])
    gl.useProgram(program)

    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(program, 'a_position')

    // Create a buffer and put a single clipspace rectangle in
    // it (2 triangles)
    var buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1.02, -1.02,
        0.0, 0.0,
        1.02, 1.02
      ]),
      gl.STATIC_DRAW)
    gl.enableVertexAttribArray(positionLocation)
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

    // draw
    gl.drawArrays(gl.POINTS, 0, 3)

  </script>
</body>

</html>
